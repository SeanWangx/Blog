## 浏览器的缓存原理

> 2020.04.15

### 缓存过程

1. 浏览器发送http请求
2. 在浏览器缓存中匹配，匹配到资源，则返回缓存资源
3. 未匹配到资源则请求服务器
4. 服务器返回资源及相关缓存字段给浏览器
5. 浏览器存储到缓存中

```
browser     cache       server
   |----1---->|            |
   |<---2-----|            |
   |----------3----------->|
   |<---------4------------|
   |----------5----------->|
```

### 实际应用场景

+ 频繁变动的资源：cache-control: no-cache
+ 不常变化的资源：cache-control: max-age = ...

### 缓存位置

+ service worker：持续的、自由的控制缓存哪些文件、如何匹配缓存、如何读取缓存
+ memory cahce：读取高效，但是持续性短，因为存在在内存中
+ disk cache：读取速度慢，但是持续性长、容量大，因为存在在磁盘中
+ push cache：存在会话（session）中，随着会话结束被释放、持续时间短

用户行为的影响：

+ 地址栏输入地址：查找disk cache，没有就发送网络
+ F5：优先使用memory cache，其次使用disk cache
+ Ctrl+F5：浏览器不使用缓存

### 缓存分类

+ 强缓存
    + expires
        + 过期时间由服务器发送资源时包含在响应头中
        + 篡改本地时间可以绕过过期时间，造成缓存失效
    + cache-control
        + max-age: 请求后的max-age时间段内有效
        + no-cache: 资源被缓存，但是立即失效，需要下次请求验证是否过期
        + private: 响应可以被客户端缓存，私有
        + public: 响应可以被客户端和代理服务器缓存，共享
    + 对比
        + expires是http/1.0的，cache-control是http/1.1的
        + cache-control优先级高于expires
+ 协商缓存
    + last-modified / if-modified-since
        + 以秒为单位，存在局限
    + etag / if-none-match
        + etag为资源唯一标示，变化即改动资源
    + 对比
        + 精确度上etag更好
        + 性能上last-modified更好
        + 服务器校验优先etag
+ 缓存机制
    + 强缓存优先于协商缓存
    + 协商缓存生效，返回304，使用缓存资源
    + 协商缓存失效，返回200，重新返回资源及缓存标示

### 优化过程

+ 不使用缓存策略：每次都请求获取新的资源
+ 使用expires：有效时间内使用缓存，过期后重新请求资源，但是本地时间篡改可使缓存失效
+ 使用last-modified/if-modified-since：增加资源上次修改时间，过期后带着上次修改时间去请求服务器，未修改使用缓存，已修改重新获取资源及缓存标示；但是精确度为秒，针对于频繁改动的资源会有误差
+ 使用etag/if-none-match：增加资源唯一标示，过期后根据资源唯一标示与服务器匹配，匹配成功使用缓存，否则使用新的资源及缓存标示

### 缓存位置详解

#### Service Worker

sw是浏览器背后的独立线程，使用到了请求拦截，因此使用https协议，不管资源是从缓存还是从服务器获取，最终都显示从service worker获取

#### Memory Cahce

内存缓存，preloader相关指令，可以一边解析js/css，一边请求资源

#### Disk Cache

#### Push Cache
