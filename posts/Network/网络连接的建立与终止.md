## 网络连接的建立与终止

> 2020.04.16

### 概念

+ SYN: 建立联机
+ ACK: 确认
+ FIN: 结束联机
+ seq: 顺序码

### 建立：三次握手

核心思想或者说实现目标：

+ 客户端：
    + 明确服务端能够正常发送、接收
    + 明确自身客户端能够正常发送、接收
+ 服务端：
    + 明确客户端能够正常发送、接收
    + 明确自身服务端能正常发送、接收

按照这样的逻辑来看必须在客户端和服务端至少有三次通信：

```
client                       server
  |-------- SYN seq=x ------->|
  |<--- SYN seq=y ACK=x+1 ----|
  |--------- ACK=y+1 -------->|
```

1. client -> server:
    1. 操作：客户端向服务端请求建立联机
2. server -> client:
    1. 操作：服务端向客户端请求建立联机，同时确认来自客户端的联机请求
    2. 结果：客户端到服务端的连接建立
3. client -> server: 
    1. 操作：客户端确认来自服务端的联机请求
    2. 结果：服务端到客户端的连接建立

顺便说一下，DDOS攻击中就有一种是利用发送建立联机请求但是不响应占用服务器资源的攻击方式。

### 终止：四次挥手

```
client                       server
  |-------- FIN seq=x ------->|
  |<------- ACK=x+1 ----------|
  |<------- FIN seq=y --------|
  |-------- ACK=y+1 --------->|
```

1. client -> server: 客户端向服务端请求结束联机
2. server -> client: 服务端响应客户端的结束联机请求
3. server -> client: 服务端向客户端请求结束联机
4. client -> server: 客户端响应服务端的结束联机请求，至此服务端关闭连接
5. client time_wait 4m: 客户端等待4m（2MSL，两个报文存活时间），之后客户端关闭连接

这里需要说明的是为什么会有第五步，而不是在第四步结束后双方都关闭连接，这是因为客户端需要保证服务端能顺利接收到 `ACK=y+1`，当服务端接收不到的时候，服务端会在第三步 `FIN seq=y` 的基础上进行一次重新发送，所以4m的等待时间(**`time_wait`状态**)是为了这里重发的可能性。

## Link

+ [上一篇：**简版Promise及相关方法实现**](../DIY/简版Promise实现.md)